// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/minskylab/meta-core/ent/credential"
	"github.com/minskylab/meta-core/ent/deployment"
	"github.com/minskylab/meta-core/ent/predicate"
	"github.com/minskylab/meta-core/ent/process"
	"github.com/minskylab/meta-core/ent/provider"
	"github.com/minskylab/meta-core/ent/stack"
	"github.com/minskylab/meta-core/ent/task"
	uuid "github.com/satori/go.uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCredential = "Credential"
	TypeDeployment = "Deployment"
	TypeProcess    = "Process"
	TypeProvider   = "Provider"
	TypeStack      = "Stack"
	TypeTask       = "Task"
)

// CredentialMutation represents an operation that mutates the Credential nodes in the graph.
type CredentialMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	registry          *string
	username          *string
	password          *string
	clearedFields     map[string]struct{}
	deployment        *uuid.UUID
	cleareddeployment bool
	done              bool
	oldValue          func(context.Context) (*Credential, error)
	predicates        []predicate.Credential
}

var _ ent.Mutation = (*CredentialMutation)(nil)

// credentialOption allows management of the mutation configuration using functional options.
type credentialOption func(*CredentialMutation)

// newCredentialMutation creates new mutation for the Credential entity.
func newCredentialMutation(c config, op Op, opts ...credentialOption) *CredentialMutation {
	m := &CredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCredentialID sets the ID field of the mutation.
func withCredentialID(id uuid.UUID) credentialOption {
	return func(m *CredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *Credential
		)
		m.oldValue = func(ctx context.Context) (*Credential, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Credential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCredential sets the old Credential of the mutation.
func withCredential(node *Credential) credentialOption {
	return func(m *CredentialMutation) {
		m.oldValue = func(context.Context) (*Credential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Credential entities.
func (m *CredentialMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CredentialMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *CredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CredentialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CredentialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CredentialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRegistry sets the "registry" field.
func (m *CredentialMutation) SetRegistry(s string) {
	m.registry = &s
}

// Registry returns the value of the "registry" field in the mutation.
func (m *CredentialMutation) Registry() (r string, exists bool) {
	v := m.registry
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistry returns the old "registry" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldRegistry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegistry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegistry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistry: %w", err)
	}
	return oldValue.Registry, nil
}

// ResetRegistry resets all changes to the "registry" field.
func (m *CredentialMutation) ResetRegistry() {
	m.registry = nil
}

// SetUsername sets the "username" field.
func (m *CredentialMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *CredentialMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *CredentialMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *CredentialMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *CredentialMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Credential entity.
// If the Credential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CredentialMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *CredentialMutation) ResetPassword() {
	m.password = nil
}

// SetDeploymentID sets the "deployment" edge to the Deployment entity by id.
func (m *CredentialMutation) SetDeploymentID(id uuid.UUID) {
	m.deployment = &id
}

// ClearDeployment clears the "deployment" edge to the Deployment entity.
func (m *CredentialMutation) ClearDeployment() {
	m.cleareddeployment = true
}

// DeploymentCleared reports if the "deployment" edge to the Deployment entity was cleared.
func (m *CredentialMutation) DeploymentCleared() bool {
	return m.cleareddeployment
}

// DeploymentID returns the "deployment" edge ID in the mutation.
func (m *CredentialMutation) DeploymentID() (id uuid.UUID, exists bool) {
	if m.deployment != nil {
		return *m.deployment, true
	}
	return
}

// DeploymentIDs returns the "deployment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentID instead. It exists only for internal usage by the builders.
func (m *CredentialMutation) DeploymentIDs() (ids []uuid.UUID) {
	if id := m.deployment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeployment resets all changes to the "deployment" edge.
func (m *CredentialMutation) ResetDeployment() {
	m.deployment = nil
	m.cleareddeployment = false
}

// Where appends a list predicates to the CredentialMutation builder.
func (m *CredentialMutation) Where(ps ...predicate.Credential) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CredentialMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Credential).
func (m *CredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CredentialMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, credential.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, credential.FieldUpdatedAt)
	}
	if m.registry != nil {
		fields = append(fields, credential.FieldRegistry)
	}
	if m.username != nil {
		fields = append(fields, credential.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, credential.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credential.FieldCreatedAt:
		return m.CreatedAt()
	case credential.FieldUpdatedAt:
		return m.UpdatedAt()
	case credential.FieldRegistry:
		return m.Registry()
	case credential.FieldUsername:
		return m.Username()
	case credential.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case credential.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case credential.FieldRegistry:
		return m.OldRegistry(ctx)
	case credential.FieldUsername:
		return m.OldUsername(ctx)
	case credential.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Credential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case credential.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case credential.FieldRegistry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistry(v)
		return nil
	case credential.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case credential.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CredentialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CredentialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Credential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CredentialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CredentialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Credential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CredentialMutation) ResetField(name string) error {
	switch name {
	case credential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case credential.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case credential.FieldRegistry:
		m.ResetRegistry()
		return nil
	case credential.FieldUsername:
		m.ResetUsername()
		return nil
	case credential.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Credential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.deployment != nil {
		edges = append(edges, credential.EdgeDeployment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credential.EdgeDeployment:
		if id := m.deployment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CredentialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddeployment {
		edges = append(edges, credential.EdgeDeployment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case credential.EdgeDeployment:
		return m.cleareddeployment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CredentialMutation) ClearEdge(name string) error {
	switch name {
	case credential.EdgeDeployment:
		m.ClearDeployment()
		return nil
	}
	return fmt.Errorf("unknown Credential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CredentialMutation) ResetEdge(name string) error {
	switch name {
	case credential.EdgeDeployment:
		m.ResetDeployment()
		return nil
	}
	return fmt.Errorf("unknown Credential edge %s", name)
}

// DeploymentMutation represents an operation that mutates the Deployment nodes in the graph.
type DeploymentMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	state              *deployment.State
	name               *string
	timeout            *int
	addtimeout         *int
	clearedFields      map[string]struct{}
	tasks              map[uuid.UUID]struct{}
	removedtasks       map[uuid.UUID]struct{}
	clearedtasks       bool
	provider           *uuid.UUID
	clearedprovider    bool
	stack              *string
	clearedstack       bool
	credentials        map[uuid.UUID]struct{}
	removedcredentials map[uuid.UUID]struct{}
	clearedcredentials bool
	done               bool
	oldValue           func(context.Context) (*Deployment, error)
	predicates         []predicate.Deployment
}

var _ ent.Mutation = (*DeploymentMutation)(nil)

// deploymentOption allows management of the mutation configuration using functional options.
type deploymentOption func(*DeploymentMutation)

// newDeploymentMutation creates new mutation for the Deployment entity.
func newDeploymentMutation(c config, op Op, opts ...deploymentOption) *DeploymentMutation {
	m := &DeploymentMutation{
		config:        c,
		op:            op,
		typ:           TypeDeployment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentID sets the ID field of the mutation.
func withDeploymentID(id uuid.UUID) deploymentOption {
	return func(m *DeploymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Deployment
		)
		m.oldValue = func(ctx context.Context) (*Deployment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deployment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeployment sets the old Deployment of the mutation.
func withDeployment(node *Deployment) deploymentOption {
	return func(m *DeploymentMutation) {
		m.oldValue = func(context.Context) (*Deployment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Deployment entities.
func (m *DeploymentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *DeploymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeploymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeploymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeploymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeploymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeploymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetState sets the "state" field.
func (m *DeploymentMutation) SetState(d deployment.State) {
	m.state = &d
}

// State returns the value of the "state" field in the mutation.
func (m *DeploymentMutation) State() (r deployment.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldState(ctx context.Context) (v deployment.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *DeploymentMutation) ResetState() {
	m.state = nil
}

// SetName sets the "name" field.
func (m *DeploymentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeploymentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DeploymentMutation) ClearName() {
	m.name = nil
	m.clearedFields[deployment.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DeploymentMutation) NameCleared() bool {
	_, ok := m.clearedFields[deployment.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DeploymentMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, deployment.FieldName)
}

// SetTimeout sets the "timeout" field.
func (m *DeploymentMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *DeploymentMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *DeploymentMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *DeploymentMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *DeploymentMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *DeploymentMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m.tasks == nil {
		m.tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *DeploymentMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *DeploymentMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *DeploymentMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *DeploymentMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *DeploymentMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *DeploymentMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// SetProviderID sets the "provider" edge to the Provider entity by id.
func (m *DeploymentMutation) SetProviderID(id uuid.UUID) {
	m.provider = &id
}

// ClearProvider clears the "provider" edge to the Provider entity.
func (m *DeploymentMutation) ClearProvider() {
	m.clearedprovider = true
}

// ProviderCleared reports if the "provider" edge to the Provider entity was cleared.
func (m *DeploymentMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderID returns the "provider" edge ID in the mutation.
func (m *DeploymentMutation) ProviderID() (id uuid.UUID, exists bool) {
	if m.provider != nil {
		return *m.provider, true
	}
	return
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *DeploymentMutation) ProviderIDs() (ids []uuid.UUID) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *DeploymentMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// SetStackID sets the "stack" edge to the Stack entity by id.
func (m *DeploymentMutation) SetStackID(id string) {
	m.stack = &id
}

// ClearStack clears the "stack" edge to the Stack entity.
func (m *DeploymentMutation) ClearStack() {
	m.clearedstack = true
}

// StackCleared reports if the "stack" edge to the Stack entity was cleared.
func (m *DeploymentMutation) StackCleared() bool {
	return m.clearedstack
}

// StackID returns the "stack" edge ID in the mutation.
func (m *DeploymentMutation) StackID() (id string, exists bool) {
	if m.stack != nil {
		return *m.stack, true
	}
	return
}

// StackIDs returns the "stack" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StackID instead. It exists only for internal usage by the builders.
func (m *DeploymentMutation) StackIDs() (ids []string) {
	if id := m.stack; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStack resets all changes to the "stack" edge.
func (m *DeploymentMutation) ResetStack() {
	m.stack = nil
	m.clearedstack = false
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *DeploymentMutation) AddCredentialIDs(ids ...uuid.UUID) {
	if m.credentials == nil {
		m.credentials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *DeploymentMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *DeploymentMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *DeploymentMutation) RemoveCredentialIDs(ids ...uuid.UUID) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *DeploymentMutation) RemovedCredentialsIDs() (ids []uuid.UUID) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *DeploymentMutation) CredentialsIDs() (ids []uuid.UUID) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *DeploymentMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// Where appends a list predicates to the DeploymentMutation builder.
func (m *DeploymentMutation) Where(ps ...predicate.Deployment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeploymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Deployment).
func (m *DeploymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, deployment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deployment.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, deployment.FieldState)
	}
	if m.name != nil {
		fields = append(fields, deployment.FieldName)
	}
	if m.timeout != nil {
		fields = append(fields, deployment.FieldTimeout)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deployment.FieldCreatedAt:
		return m.CreatedAt()
	case deployment.FieldUpdatedAt:
		return m.UpdatedAt()
	case deployment.FieldState:
		return m.State()
	case deployment.FieldName:
		return m.Name()
	case deployment.FieldTimeout:
		return m.Timeout()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deployment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deployment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deployment.FieldState:
		return m.OldState(ctx)
	case deployment.FieldName:
		return m.OldName(ctx)
	case deployment.FieldTimeout:
		return m.OldTimeout(ctx)
	}
	return nil, fmt.Errorf("unknown Deployment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deployment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deployment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deployment.FieldState:
		v, ok := value.(deployment.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case deployment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deployment.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentMutation) AddedFields() []string {
	var fields []string
	if m.addtimeout != nil {
		fields = append(fields, deployment.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deployment.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deployment.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Deployment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deployment.FieldName) {
		fields = append(fields, deployment.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentMutation) ClearField(name string) error {
	switch name {
	case deployment.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Deployment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentMutation) ResetField(name string) error {
	switch name {
	case deployment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deployment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deployment.FieldState:
		m.ResetState()
		return nil
	case deployment.FieldName:
		m.ResetName()
		return nil
	case deployment.FieldTimeout:
		m.ResetTimeout()
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tasks != nil {
		edges = append(edges, deployment.EdgeTasks)
	}
	if m.provider != nil {
		edges = append(edges, deployment.EdgeProvider)
	}
	if m.stack != nil {
		edges = append(edges, deployment.EdgeStack)
	}
	if m.credentials != nil {
		edges = append(edges, deployment.EdgeCredentials)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deployment.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case deployment.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	case deployment.EdgeStack:
		if id := m.stack; id != nil {
			return []ent.Value{*id}
		}
	case deployment.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtasks != nil {
		edges = append(edges, deployment.EdgeTasks)
	}
	if m.removedcredentials != nil {
		edges = append(edges, deployment.EdgeCredentials)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deployment.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case deployment.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtasks {
		edges = append(edges, deployment.EdgeTasks)
	}
	if m.clearedprovider {
		edges = append(edges, deployment.EdgeProvider)
	}
	if m.clearedstack {
		edges = append(edges, deployment.EdgeStack)
	}
	if m.clearedcredentials {
		edges = append(edges, deployment.EdgeCredentials)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentMutation) EdgeCleared(name string) bool {
	switch name {
	case deployment.EdgeTasks:
		return m.clearedtasks
	case deployment.EdgeProvider:
		return m.clearedprovider
	case deployment.EdgeStack:
		return m.clearedstack
	case deployment.EdgeCredentials:
		return m.clearedcredentials
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentMutation) ClearEdge(name string) error {
	switch name {
	case deployment.EdgeProvider:
		m.ClearProvider()
		return nil
	case deployment.EdgeStack:
		m.ClearStack()
		return nil
	}
	return fmt.Errorf("unknown Deployment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentMutation) ResetEdge(name string) error {
	switch name {
	case deployment.EdgeTasks:
		m.ResetTasks()
		return nil
	case deployment.EdgeProvider:
		m.ResetProvider()
		return nil
	case deployment.EdgeStack:
		m.ResetStack()
		return nil
	case deployment.EdgeCredentials:
		m.ResetCredentials()
		return nil
	}
	return fmt.Errorf("unknown Deployment edge %s", name)
}

// ProcessMutation represents an operation that mutates the Process nodes in the graph.
type ProcessMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	token              *string
	instance_type      *string
	ami_id             *string
	resource_prefix    *string
	timeout            *int
	addtimeout         *int
	expiration         *int
	addexpiration      *int
	state              *process.State
	clearedFields      map[string]struct{}
	stack              *string
	clearedstack       bool
	credentials        map[uuid.UUID]struct{}
	removedcredentials map[uuid.UUID]struct{}
	clearedcredentials bool
	tasks              map[uuid.UUID]struct{}
	removedtasks       map[uuid.UUID]struct{}
	clearedtasks       bool
	done               bool
	oldValue           func(context.Context) (*Process, error)
	predicates         []predicate.Process
}

var _ ent.Mutation = (*ProcessMutation)(nil)

// processOption allows management of the mutation configuration using functional options.
type processOption func(*ProcessMutation)

// newProcessMutation creates new mutation for the Process entity.
func newProcessMutation(c config, op Op, opts ...processOption) *ProcessMutation {
	m := &ProcessMutation{
		config:        c,
		op:            op,
		typ:           TypeProcess,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessID sets the ID field of the mutation.
func withProcessID(id string) processOption {
	return func(m *ProcessMutation) {
		var (
			err   error
			once  sync.Once
			value *Process
		)
		m.oldValue = func(ctx context.Context) (*Process, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Process.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcess sets the old Process of the mutation.
func withProcess(node *Process) processOption {
	return func(m *ProcessMutation) {
		m.oldValue = func(context.Context) (*Process, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Process entities.
func (m *ProcessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ProcessMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcessMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProcessMutation) ClearName() {
	m.name = nil
	m.clearedFields[process.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProcessMutation) NameCleared() bool {
	_, ok := m.clearedFields[process.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProcessMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, process.FieldName)
}

// SetToken sets the "token" field.
func (m *ProcessMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *ProcessMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *ProcessMutation) ResetToken() {
	m.token = nil
}

// SetInstanceType sets the "instance_type" field.
func (m *ProcessMutation) SetInstanceType(s string) {
	m.instance_type = &s
}

// InstanceType returns the value of the "instance_type" field in the mutation.
func (m *ProcessMutation) InstanceType() (r string, exists bool) {
	v := m.instance_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceType returns the old "instance_type" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldInstanceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstanceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstanceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceType: %w", err)
	}
	return oldValue.InstanceType, nil
}

// ResetInstanceType resets all changes to the "instance_type" field.
func (m *ProcessMutation) ResetInstanceType() {
	m.instance_type = nil
}

// SetAmiID sets the "ami_id" field.
func (m *ProcessMutation) SetAmiID(s string) {
	m.ami_id = &s
}

// AmiID returns the value of the "ami_id" field in the mutation.
func (m *ProcessMutation) AmiID() (r string, exists bool) {
	v := m.ami_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAmiID returns the old "ami_id" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldAmiID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmiID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmiID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmiID: %w", err)
	}
	return oldValue.AmiID, nil
}

// ResetAmiID resets all changes to the "ami_id" field.
func (m *ProcessMutation) ResetAmiID() {
	m.ami_id = nil
}

// SetResourcePrefix sets the "resource_prefix" field.
func (m *ProcessMutation) SetResourcePrefix(s string) {
	m.resource_prefix = &s
}

// ResourcePrefix returns the value of the "resource_prefix" field in the mutation.
func (m *ProcessMutation) ResourcePrefix() (r string, exists bool) {
	v := m.resource_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldResourcePrefix returns the old "resource_prefix" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldResourcePrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResourcePrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResourcePrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourcePrefix: %w", err)
	}
	return oldValue.ResourcePrefix, nil
}

// ResetResourcePrefix resets all changes to the "resource_prefix" field.
func (m *ProcessMutation) ResetResourcePrefix() {
	m.resource_prefix = nil
}

// SetTimeout sets the "timeout" field.
func (m *ProcessMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ProcessMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *ProcessMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *ProcessMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeout clears the value of the "timeout" field.
func (m *ProcessMutation) ClearTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	m.clearedFields[process.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *ProcessMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[process.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ProcessMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	delete(m.clearedFields, process.FieldTimeout)
}

// SetExpiration sets the "expiration" field.
func (m *ProcessMutation) SetExpiration(i int) {
	m.expiration = &i
	m.addexpiration = nil
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *ProcessMutation) Expiration() (r int, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldExpiration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// AddExpiration adds i to the "expiration" field.
func (m *ProcessMutation) AddExpiration(i int) {
	if m.addexpiration != nil {
		*m.addexpiration += i
	} else {
		m.addexpiration = &i
	}
}

// AddedExpiration returns the value that was added to the "expiration" field in this mutation.
func (m *ProcessMutation) AddedExpiration() (r int, exists bool) {
	v := m.addexpiration
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *ProcessMutation) ResetExpiration() {
	m.expiration = nil
	m.addexpiration = nil
}

// SetState sets the "state" field.
func (m *ProcessMutation) SetState(pr process.State) {
	m.state = &pr
}

// State returns the value of the "state" field in the mutation.
func (m *ProcessMutation) State() (r process.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Process entity.
// If the Process object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessMutation) OldState(ctx context.Context) (v process.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *ProcessMutation) ResetState() {
	m.state = nil
}

// SetStackID sets the "stack" edge to the Stack entity by id.
func (m *ProcessMutation) SetStackID(id string) {
	m.stack = &id
}

// ClearStack clears the "stack" edge to the Stack entity.
func (m *ProcessMutation) ClearStack() {
	m.clearedstack = true
}

// StackCleared reports if the "stack" edge to the Stack entity was cleared.
func (m *ProcessMutation) StackCleared() bool {
	return m.clearedstack
}

// StackID returns the "stack" edge ID in the mutation.
func (m *ProcessMutation) StackID() (id string, exists bool) {
	if m.stack != nil {
		return *m.stack, true
	}
	return
}

// StackIDs returns the "stack" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StackID instead. It exists only for internal usage by the builders.
func (m *ProcessMutation) StackIDs() (ids []string) {
	if id := m.stack; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStack resets all changes to the "stack" edge.
func (m *ProcessMutation) ResetStack() {
	m.stack = nil
	m.clearedstack = false
}

// AddCredentialIDs adds the "credentials" edge to the Credential entity by ids.
func (m *ProcessMutation) AddCredentialIDs(ids ...uuid.UUID) {
	if m.credentials == nil {
		m.credentials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.credentials[ids[i]] = struct{}{}
	}
}

// ClearCredentials clears the "credentials" edge to the Credential entity.
func (m *ProcessMutation) ClearCredentials() {
	m.clearedcredentials = true
}

// CredentialsCleared reports if the "credentials" edge to the Credential entity was cleared.
func (m *ProcessMutation) CredentialsCleared() bool {
	return m.clearedcredentials
}

// RemoveCredentialIDs removes the "credentials" edge to the Credential entity by IDs.
func (m *ProcessMutation) RemoveCredentialIDs(ids ...uuid.UUID) {
	if m.removedcredentials == nil {
		m.removedcredentials = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.credentials, ids[i])
		m.removedcredentials[ids[i]] = struct{}{}
	}
}

// RemovedCredentials returns the removed IDs of the "credentials" edge to the Credential entity.
func (m *ProcessMutation) RemovedCredentialsIDs() (ids []uuid.UUID) {
	for id := range m.removedcredentials {
		ids = append(ids, id)
	}
	return
}

// CredentialsIDs returns the "credentials" edge IDs in the mutation.
func (m *ProcessMutation) CredentialsIDs() (ids []uuid.UUID) {
	for id := range m.credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCredentials resets all changes to the "credentials" edge.
func (m *ProcessMutation) ResetCredentials() {
	m.credentials = nil
	m.clearedcredentials = false
	m.removedcredentials = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ProcessMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m.tasks == nil {
		m.tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ProcessMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ProcessMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ProcessMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ProcessMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ProcessMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ProcessMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the ProcessMutation builder.
func (m *ProcessMutation) Where(ps ...predicate.Process) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProcessMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Process).
func (m *ProcessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, process.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, process.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, process.FieldName)
	}
	if m.token != nil {
		fields = append(fields, process.FieldToken)
	}
	if m.instance_type != nil {
		fields = append(fields, process.FieldInstanceType)
	}
	if m.ami_id != nil {
		fields = append(fields, process.FieldAmiID)
	}
	if m.resource_prefix != nil {
		fields = append(fields, process.FieldResourcePrefix)
	}
	if m.timeout != nil {
		fields = append(fields, process.FieldTimeout)
	}
	if m.expiration != nil {
		fields = append(fields, process.FieldExpiration)
	}
	if m.state != nil {
		fields = append(fields, process.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case process.FieldCreatedAt:
		return m.CreatedAt()
	case process.FieldUpdatedAt:
		return m.UpdatedAt()
	case process.FieldName:
		return m.Name()
	case process.FieldToken:
		return m.Token()
	case process.FieldInstanceType:
		return m.InstanceType()
	case process.FieldAmiID:
		return m.AmiID()
	case process.FieldResourcePrefix:
		return m.ResourcePrefix()
	case process.FieldTimeout:
		return m.Timeout()
	case process.FieldExpiration:
		return m.Expiration()
	case process.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case process.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case process.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case process.FieldName:
		return m.OldName(ctx)
	case process.FieldToken:
		return m.OldToken(ctx)
	case process.FieldInstanceType:
		return m.OldInstanceType(ctx)
	case process.FieldAmiID:
		return m.OldAmiID(ctx)
	case process.FieldResourcePrefix:
		return m.OldResourcePrefix(ctx)
	case process.FieldTimeout:
		return m.OldTimeout(ctx)
	case process.FieldExpiration:
		return m.OldExpiration(ctx)
	case process.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Process field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case process.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case process.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case process.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case process.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case process.FieldInstanceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceType(v)
		return nil
	case process.FieldAmiID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmiID(v)
		return nil
	case process.FieldResourcePrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourcePrefix(v)
		return nil
	case process.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case process.FieldExpiration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case process.FieldState:
		v, ok := value.(process.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Process field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessMutation) AddedFields() []string {
	var fields []string
	if m.addtimeout != nil {
		fields = append(fields, process.FieldTimeout)
	}
	if m.addexpiration != nil {
		fields = append(fields, process.FieldExpiration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case process.FieldTimeout:
		return m.AddedTimeout()
	case process.FieldExpiration:
		return m.AddedExpiration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessMutation) AddField(name string, value ent.Value) error {
	switch name {
	case process.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	case process.FieldExpiration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpiration(v)
		return nil
	}
	return fmt.Errorf("unknown Process numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(process.FieldName) {
		fields = append(fields, process.FieldName)
	}
	if m.FieldCleared(process.FieldTimeout) {
		fields = append(fields, process.FieldTimeout)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessMutation) ClearField(name string) error {
	switch name {
	case process.FieldName:
		m.ClearName()
		return nil
	case process.FieldTimeout:
		m.ClearTimeout()
		return nil
	}
	return fmt.Errorf("unknown Process nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessMutation) ResetField(name string) error {
	switch name {
	case process.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case process.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case process.FieldName:
		m.ResetName()
		return nil
	case process.FieldToken:
		m.ResetToken()
		return nil
	case process.FieldInstanceType:
		m.ResetInstanceType()
		return nil
	case process.FieldAmiID:
		m.ResetAmiID()
		return nil
	case process.FieldResourcePrefix:
		m.ResetResourcePrefix()
		return nil
	case process.FieldTimeout:
		m.ResetTimeout()
		return nil
	case process.FieldExpiration:
		m.ResetExpiration()
		return nil
	case process.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Process field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.stack != nil {
		edges = append(edges, process.EdgeStack)
	}
	if m.credentials != nil {
		edges = append(edges, process.EdgeCredentials)
	}
	if m.tasks != nil {
		edges = append(edges, process.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case process.EdgeStack:
		if id := m.stack; id != nil {
			return []ent.Value{*id}
		}
	case process.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.credentials))
		for id := range m.credentials {
			ids = append(ids, id)
		}
		return ids
	case process.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcredentials != nil {
		edges = append(edges, process.EdgeCredentials)
	}
	if m.removedtasks != nil {
		edges = append(edges, process.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case process.EdgeCredentials:
		ids := make([]ent.Value, 0, len(m.removedcredentials))
		for id := range m.removedcredentials {
			ids = append(ids, id)
		}
		return ids
	case process.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstack {
		edges = append(edges, process.EdgeStack)
	}
	if m.clearedcredentials {
		edges = append(edges, process.EdgeCredentials)
	}
	if m.clearedtasks {
		edges = append(edges, process.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessMutation) EdgeCleared(name string) bool {
	switch name {
	case process.EdgeStack:
		return m.clearedstack
	case process.EdgeCredentials:
		return m.clearedcredentials
	case process.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessMutation) ClearEdge(name string) error {
	switch name {
	case process.EdgeStack:
		m.ClearStack()
		return nil
	}
	return fmt.Errorf("unknown Process unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessMutation) ResetEdge(name string) error {
	switch name {
	case process.EdgeStack:
		m.ResetStack()
		return nil
	case process.EdgeCredentials:
		m.ResetCredentials()
		return nil
	case process.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown Process edge %s", name)
}

// ProviderMutation represents an operation that mutates the Provider nodes in the graph.
type ProviderMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	hostname          *string
	token             *string
	clearedFields     map[string]struct{}
	deployment        map[uuid.UUID]struct{}
	removeddeployment map[uuid.UUID]struct{}
	cleareddeployment bool
	done              bool
	oldValue          func(context.Context) (*Provider, error)
	predicates        []predicate.Provider
}

var _ ent.Mutation = (*ProviderMutation)(nil)

// providerOption allows management of the mutation configuration using functional options.
type providerOption func(*ProviderMutation)

// newProviderMutation creates new mutation for the Provider entity.
func newProviderMutation(c config, op Op, opts ...providerOption) *ProviderMutation {
	m := &ProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProviderID sets the ID field of the mutation.
func withProviderID(id uuid.UUID) providerOption {
	return func(m *ProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *Provider
		)
		m.oldValue = func(ctx context.Context) (*Provider, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Provider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvider sets the old Provider of the mutation.
func withProvider(node *Provider) providerOption {
	return func(m *ProviderMutation) {
		m.oldValue = func(context.Context) (*Provider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Provider entities.
func (m *ProviderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProviderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHostname sets the "hostname" field.
func (m *ProviderMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *ProviderMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *ProviderMutation) ResetHostname() {
	m.hostname = nil
}

// SetToken sets the "token" field.
func (m *ProviderMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *ProviderMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Provider entity.
// If the Provider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProviderMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *ProviderMutation) ResetToken() {
	m.token = nil
}

// AddDeploymentIDs adds the "deployment" edge to the Deployment entity by ids.
func (m *ProviderMutation) AddDeploymentIDs(ids ...uuid.UUID) {
	if m.deployment == nil {
		m.deployment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.deployment[ids[i]] = struct{}{}
	}
}

// ClearDeployment clears the "deployment" edge to the Deployment entity.
func (m *ProviderMutation) ClearDeployment() {
	m.cleareddeployment = true
}

// DeploymentCleared reports if the "deployment" edge to the Deployment entity was cleared.
func (m *ProviderMutation) DeploymentCleared() bool {
	return m.cleareddeployment
}

// RemoveDeploymentIDs removes the "deployment" edge to the Deployment entity by IDs.
func (m *ProviderMutation) RemoveDeploymentIDs(ids ...uuid.UUID) {
	if m.removeddeployment == nil {
		m.removeddeployment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.deployment, ids[i])
		m.removeddeployment[ids[i]] = struct{}{}
	}
}

// RemovedDeployment returns the removed IDs of the "deployment" edge to the Deployment entity.
func (m *ProviderMutation) RemovedDeploymentIDs() (ids []uuid.UUID) {
	for id := range m.removeddeployment {
		ids = append(ids, id)
	}
	return
}

// DeploymentIDs returns the "deployment" edge IDs in the mutation.
func (m *ProviderMutation) DeploymentIDs() (ids []uuid.UUID) {
	for id := range m.deployment {
		ids = append(ids, id)
	}
	return
}

// ResetDeployment resets all changes to the "deployment" edge.
func (m *ProviderMutation) ResetDeployment() {
	m.deployment = nil
	m.cleareddeployment = false
	m.removeddeployment = nil
}

// Where appends a list predicates to the ProviderMutation builder.
func (m *ProviderMutation) Where(ps ...predicate.Provider) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProviderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Provider).
func (m *ProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProviderMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, provider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, provider.FieldUpdatedAt)
	}
	if m.hostname != nil {
		fields = append(fields, provider.FieldHostname)
	}
	if m.token != nil {
		fields = append(fields, provider.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provider.FieldCreatedAt:
		return m.CreatedAt()
	case provider.FieldUpdatedAt:
		return m.UpdatedAt()
	case provider.FieldHostname:
		return m.Hostname()
	case provider.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case provider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case provider.FieldHostname:
		return m.OldHostname(ctx)
	case provider.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown Provider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case provider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case provider.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case provider.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProviderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProviderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Provider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProviderMutation) ResetField(name string) error {
	switch name {
	case provider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case provider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case provider.FieldHostname:
		m.ResetHostname()
		return nil
	case provider.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown Provider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.deployment != nil {
		edges = append(edges, provider.EdgeDeployment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeDeployment:
		ids := make([]ent.Value, 0, len(m.deployment))
		for id := range m.deployment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddeployment != nil {
		edges = append(edges, provider.EdgeDeployment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provider.EdgeDeployment:
		ids := make([]ent.Value, 0, len(m.removeddeployment))
		for id := range m.removeddeployment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddeployment {
		edges = append(edges, provider.EdgeDeployment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case provider.EdgeDeployment:
		return m.cleareddeployment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProviderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Provider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProviderMutation) ResetEdge(name string) error {
	switch name {
	case provider.EdgeDeployment:
		m.ResetDeployment()
		return nil
	}
	return fmt.Errorf("unknown Provider edge %s", name)
}

// StackMutation represents an operation that mutates the Stack nodes in the graph.
type StackMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	instance          *string
	vpc_id            *string
	public_ip         *string
	public_dns        *string
	username          *string
	security_group    *string
	key_pair          *string
	name              *string
	private_key       *string
	filepath          *string
	clearedFields     map[string]struct{}
	deployment        *uuid.UUID
	cleareddeployment bool
	done              bool
	oldValue          func(context.Context) (*Stack, error)
	predicates        []predicate.Stack
}

var _ ent.Mutation = (*StackMutation)(nil)

// stackOption allows management of the mutation configuration using functional options.
type stackOption func(*StackMutation)

// newStackMutation creates new mutation for the Stack entity.
func newStackMutation(c config, op Op, opts ...stackOption) *StackMutation {
	m := &StackMutation{
		config:        c,
		op:            op,
		typ:           TypeStack,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStackID sets the ID field of the mutation.
func withStackID(id string) stackOption {
	return func(m *StackMutation) {
		var (
			err   error
			once  sync.Once
			value *Stack
		)
		m.oldValue = func(ctx context.Context) (*Stack, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stack.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStack sets the old Stack of the mutation.
func withStack(node *Stack) stackOption {
	return func(m *StackMutation) {
		m.oldValue = func(context.Context) (*Stack, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stack entities.
func (m *StackMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StackMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *StackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StackMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInstance sets the "instance" field.
func (m *StackMutation) SetInstance(s string) {
	m.instance = &s
}

// Instance returns the value of the "instance" field in the mutation.
func (m *StackMutation) Instance() (r string, exists bool) {
	v := m.instance
	if v == nil {
		return
	}
	return *v, true
}

// OldInstance returns the old "instance" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldInstance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstance: %w", err)
	}
	return oldValue.Instance, nil
}

// ResetInstance resets all changes to the "instance" field.
func (m *StackMutation) ResetInstance() {
	m.instance = nil
}

// SetVpcID sets the "vpc_id" field.
func (m *StackMutation) SetVpcID(s string) {
	m.vpc_id = &s
}

// VpcID returns the value of the "vpc_id" field in the mutation.
func (m *StackMutation) VpcID() (r string, exists bool) {
	v := m.vpc_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVpcID returns the old "vpc_id" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldVpcID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVpcID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVpcID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVpcID: %w", err)
	}
	return oldValue.VpcID, nil
}

// ResetVpcID resets all changes to the "vpc_id" field.
func (m *StackMutation) ResetVpcID() {
	m.vpc_id = nil
}

// SetPublicIP sets the "public_ip" field.
func (m *StackMutation) SetPublicIP(s string) {
	m.public_ip = &s
}

// PublicIP returns the value of the "public_ip" field in the mutation.
func (m *StackMutation) PublicIP() (r string, exists bool) {
	v := m.public_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicIP returns the old "public_ip" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldPublicIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublicIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublicIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicIP: %w", err)
	}
	return oldValue.PublicIP, nil
}

// ResetPublicIP resets all changes to the "public_ip" field.
func (m *StackMutation) ResetPublicIP() {
	m.public_ip = nil
}

// SetPublicDNS sets the "public_dns" field.
func (m *StackMutation) SetPublicDNS(s string) {
	m.public_dns = &s
}

// PublicDNS returns the value of the "public_dns" field in the mutation.
func (m *StackMutation) PublicDNS() (r string, exists bool) {
	v := m.public_dns
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicDNS returns the old "public_dns" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldPublicDNS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublicDNS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublicDNS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicDNS: %w", err)
	}
	return oldValue.PublicDNS, nil
}

// ClearPublicDNS clears the value of the "public_dns" field.
func (m *StackMutation) ClearPublicDNS() {
	m.public_dns = nil
	m.clearedFields[stack.FieldPublicDNS] = struct{}{}
}

// PublicDNSCleared returns if the "public_dns" field was cleared in this mutation.
func (m *StackMutation) PublicDNSCleared() bool {
	_, ok := m.clearedFields[stack.FieldPublicDNS]
	return ok
}

// ResetPublicDNS resets all changes to the "public_dns" field.
func (m *StackMutation) ResetPublicDNS() {
	m.public_dns = nil
	delete(m.clearedFields, stack.FieldPublicDNS)
}

// SetUsername sets the "username" field.
func (m *StackMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *StackMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *StackMutation) ResetUsername() {
	m.username = nil
}

// SetSecurityGroup sets the "security_group" field.
func (m *StackMutation) SetSecurityGroup(s string) {
	m.security_group = &s
}

// SecurityGroup returns the value of the "security_group" field in the mutation.
func (m *StackMutation) SecurityGroup() (r string, exists bool) {
	v := m.security_group
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityGroup returns the old "security_group" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldSecurityGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSecurityGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSecurityGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityGroup: %w", err)
	}
	return oldValue.SecurityGroup, nil
}

// ResetSecurityGroup resets all changes to the "security_group" field.
func (m *StackMutation) ResetSecurityGroup() {
	m.security_group = nil
}

// SetKeyPair sets the "key_pair" field.
func (m *StackMutation) SetKeyPair(s string) {
	m.key_pair = &s
}

// KeyPair returns the value of the "key_pair" field in the mutation.
func (m *StackMutation) KeyPair() (r string, exists bool) {
	v := m.key_pair
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPair returns the old "key_pair" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldKeyPair(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKeyPair is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKeyPair requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPair: %w", err)
	}
	return oldValue.KeyPair, nil
}

// ResetKeyPair resets all changes to the "key_pair" field.
func (m *StackMutation) ResetKeyPair() {
	m.key_pair = nil
}

// SetName sets the "name" field.
func (m *StackMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StackMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StackMutation) ResetName() {
	m.name = nil
}

// SetPrivateKey sets the "private_key" field.
func (m *StackMutation) SetPrivateKey(s string) {
	m.private_key = &s
}

// PrivateKey returns the value of the "private_key" field in the mutation.
func (m *StackMutation) PrivateKey() (r string, exists bool) {
	v := m.private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "private_key" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldPrivateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ResetPrivateKey resets all changes to the "private_key" field.
func (m *StackMutation) ResetPrivateKey() {
	m.private_key = nil
}

// SetFilepath sets the "filepath" field.
func (m *StackMutation) SetFilepath(s string) {
	m.filepath = &s
}

// Filepath returns the value of the "filepath" field in the mutation.
func (m *StackMutation) Filepath() (r string, exists bool) {
	v := m.filepath
	if v == nil {
		return
	}
	return *v, true
}

// OldFilepath returns the old "filepath" field's value of the Stack entity.
// If the Stack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StackMutation) OldFilepath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFilepath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFilepath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilepath: %w", err)
	}
	return oldValue.Filepath, nil
}

// ClearFilepath clears the value of the "filepath" field.
func (m *StackMutation) ClearFilepath() {
	m.filepath = nil
	m.clearedFields[stack.FieldFilepath] = struct{}{}
}

// FilepathCleared returns if the "filepath" field was cleared in this mutation.
func (m *StackMutation) FilepathCleared() bool {
	_, ok := m.clearedFields[stack.FieldFilepath]
	return ok
}

// ResetFilepath resets all changes to the "filepath" field.
func (m *StackMutation) ResetFilepath() {
	m.filepath = nil
	delete(m.clearedFields, stack.FieldFilepath)
}

// SetDeploymentID sets the "deployment" edge to the Deployment entity by id.
func (m *StackMutation) SetDeploymentID(id uuid.UUID) {
	m.deployment = &id
}

// ClearDeployment clears the "deployment" edge to the Deployment entity.
func (m *StackMutation) ClearDeployment() {
	m.cleareddeployment = true
}

// DeploymentCleared reports if the "deployment" edge to the Deployment entity was cleared.
func (m *StackMutation) DeploymentCleared() bool {
	return m.cleareddeployment
}

// DeploymentID returns the "deployment" edge ID in the mutation.
func (m *StackMutation) DeploymentID() (id uuid.UUID, exists bool) {
	if m.deployment != nil {
		return *m.deployment, true
	}
	return
}

// DeploymentIDs returns the "deployment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentID instead. It exists only for internal usage by the builders.
func (m *StackMutation) DeploymentIDs() (ids []uuid.UUID) {
	if id := m.deployment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeployment resets all changes to the "deployment" edge.
func (m *StackMutation) ResetDeployment() {
	m.deployment = nil
	m.cleareddeployment = false
}

// Where appends a list predicates to the StackMutation builder.
func (m *StackMutation) Where(ps ...predicate.Stack) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StackMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stack).
func (m *StackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StackMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, stack.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stack.FieldUpdatedAt)
	}
	if m.instance != nil {
		fields = append(fields, stack.FieldInstance)
	}
	if m.vpc_id != nil {
		fields = append(fields, stack.FieldVpcID)
	}
	if m.public_ip != nil {
		fields = append(fields, stack.FieldPublicIP)
	}
	if m.public_dns != nil {
		fields = append(fields, stack.FieldPublicDNS)
	}
	if m.username != nil {
		fields = append(fields, stack.FieldUsername)
	}
	if m.security_group != nil {
		fields = append(fields, stack.FieldSecurityGroup)
	}
	if m.key_pair != nil {
		fields = append(fields, stack.FieldKeyPair)
	}
	if m.name != nil {
		fields = append(fields, stack.FieldName)
	}
	if m.private_key != nil {
		fields = append(fields, stack.FieldPrivateKey)
	}
	if m.filepath != nil {
		fields = append(fields, stack.FieldFilepath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stack.FieldCreatedAt:
		return m.CreatedAt()
	case stack.FieldUpdatedAt:
		return m.UpdatedAt()
	case stack.FieldInstance:
		return m.Instance()
	case stack.FieldVpcID:
		return m.VpcID()
	case stack.FieldPublicIP:
		return m.PublicIP()
	case stack.FieldPublicDNS:
		return m.PublicDNS()
	case stack.FieldUsername:
		return m.Username()
	case stack.FieldSecurityGroup:
		return m.SecurityGroup()
	case stack.FieldKeyPair:
		return m.KeyPair()
	case stack.FieldName:
		return m.Name()
	case stack.FieldPrivateKey:
		return m.PrivateKey()
	case stack.FieldFilepath:
		return m.Filepath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stack.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stack.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stack.FieldInstance:
		return m.OldInstance(ctx)
	case stack.FieldVpcID:
		return m.OldVpcID(ctx)
	case stack.FieldPublicIP:
		return m.OldPublicIP(ctx)
	case stack.FieldPublicDNS:
		return m.OldPublicDNS(ctx)
	case stack.FieldUsername:
		return m.OldUsername(ctx)
	case stack.FieldSecurityGroup:
		return m.OldSecurityGroup(ctx)
	case stack.FieldKeyPair:
		return m.OldKeyPair(ctx)
	case stack.FieldName:
		return m.OldName(ctx)
	case stack.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	case stack.FieldFilepath:
		return m.OldFilepath(ctx)
	}
	return nil, fmt.Errorf("unknown Stack field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stack.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stack.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stack.FieldInstance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstance(v)
		return nil
	case stack.FieldVpcID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVpcID(v)
		return nil
	case stack.FieldPublicIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicIP(v)
		return nil
	case stack.FieldPublicDNS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicDNS(v)
		return nil
	case stack.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case stack.FieldSecurityGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityGroup(v)
		return nil
	case stack.FieldKeyPair:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPair(v)
		return nil
	case stack.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case stack.FieldPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	case stack.FieldFilepath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilepath(v)
		return nil
	}
	return fmt.Errorf("unknown Stack field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StackMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StackMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Stack numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stack.FieldPublicDNS) {
		fields = append(fields, stack.FieldPublicDNS)
	}
	if m.FieldCleared(stack.FieldFilepath) {
		fields = append(fields, stack.FieldFilepath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StackMutation) ClearField(name string) error {
	switch name {
	case stack.FieldPublicDNS:
		m.ClearPublicDNS()
		return nil
	case stack.FieldFilepath:
		m.ClearFilepath()
		return nil
	}
	return fmt.Errorf("unknown Stack nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StackMutation) ResetField(name string) error {
	switch name {
	case stack.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stack.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stack.FieldInstance:
		m.ResetInstance()
		return nil
	case stack.FieldVpcID:
		m.ResetVpcID()
		return nil
	case stack.FieldPublicIP:
		m.ResetPublicIP()
		return nil
	case stack.FieldPublicDNS:
		m.ResetPublicDNS()
		return nil
	case stack.FieldUsername:
		m.ResetUsername()
		return nil
	case stack.FieldSecurityGroup:
		m.ResetSecurityGroup()
		return nil
	case stack.FieldKeyPair:
		m.ResetKeyPair()
		return nil
	case stack.FieldName:
		m.ResetName()
		return nil
	case stack.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	case stack.FieldFilepath:
		m.ResetFilepath()
		return nil
	}
	return fmt.Errorf("unknown Stack field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StackMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.deployment != nil {
		edges = append(edges, stack.EdgeDeployment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stack.EdgeDeployment:
		if id := m.deployment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StackMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddeployment {
		edges = append(edges, stack.EdgeDeployment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StackMutation) EdgeCleared(name string) bool {
	switch name {
	case stack.EdgeDeployment:
		return m.cleareddeployment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StackMutation) ClearEdge(name string) error {
	switch name {
	case stack.EdgeDeployment:
		m.ClearDeployment()
		return nil
	}
	return fmt.Errorf("unknown Stack unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StackMutation) ResetEdge(name string) error {
	switch name {
	case stack.EdgeDeployment:
		m.ResetDeployment()
		return nil
	}
	return fmt.Errorf("unknown Stack edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	image             *string
	timeout           *int
	addtimeout        *int
	name              *string
	cmd               *string
	detached          *bool
	environment       *map[string]interface{}
	ports             *[]string
	volumes           *[]string
	restart           *string
	security_opt      *[]string
	cap_add           *[]string
	clearedFields     map[string]struct{}
	deployment        *uuid.UUID
	cleareddeployment bool
	done              bool
	oldValue          func(context.Context) (*Task, error)
	predicates        []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetImage sets the "image" field.
func (m *TaskMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *TaskMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *TaskMutation) ResetImage() {
	m.image = nil
}

// SetTimeout sets the "timeout" field.
func (m *TaskMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *TaskMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *TaskMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *TaskMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeout clears the value of the "timeout" field.
func (m *TaskMutation) ClearTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	m.clearedFields[task.FieldTimeout] = struct{}{}
}

// TimeoutCleared returns if the "timeout" field was cleared in this mutation.
func (m *TaskMutation) TimeoutCleared() bool {
	_, ok := m.clearedFields[task.FieldTimeout]
	return ok
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *TaskMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
	delete(m.clearedFields, task.FieldTimeout)
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TaskMutation) ClearName() {
	m.name = nil
	m.clearedFields[task.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TaskMutation) NameCleared() bool {
	_, ok := m.clearedFields[task.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, task.FieldName)
}

// SetCmd sets the "cmd" field.
func (m *TaskMutation) SetCmd(s string) {
	m.cmd = &s
}

// Cmd returns the value of the "cmd" field in the mutation.
func (m *TaskMutation) Cmd() (r string, exists bool) {
	v := m.cmd
	if v == nil {
		return
	}
	return *v, true
}

// OldCmd returns the old "cmd" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCmd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmd: %w", err)
	}
	return oldValue.Cmd, nil
}

// ClearCmd clears the value of the "cmd" field.
func (m *TaskMutation) ClearCmd() {
	m.cmd = nil
	m.clearedFields[task.FieldCmd] = struct{}{}
}

// CmdCleared returns if the "cmd" field was cleared in this mutation.
func (m *TaskMutation) CmdCleared() bool {
	_, ok := m.clearedFields[task.FieldCmd]
	return ok
}

// ResetCmd resets all changes to the "cmd" field.
func (m *TaskMutation) ResetCmd() {
	m.cmd = nil
	delete(m.clearedFields, task.FieldCmd)
}

// SetDetached sets the "detached" field.
func (m *TaskMutation) SetDetached(b bool) {
	m.detached = &b
}

// Detached returns the value of the "detached" field in the mutation.
func (m *TaskMutation) Detached() (r bool, exists bool) {
	v := m.detached
	if v == nil {
		return
	}
	return *v, true
}

// OldDetached returns the old "detached" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDetached(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetached is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetached requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetached: %w", err)
	}
	return oldValue.Detached, nil
}

// ClearDetached clears the value of the "detached" field.
func (m *TaskMutation) ClearDetached() {
	m.detached = nil
	m.clearedFields[task.FieldDetached] = struct{}{}
}

// DetachedCleared returns if the "detached" field was cleared in this mutation.
func (m *TaskMutation) DetachedCleared() bool {
	_, ok := m.clearedFields[task.FieldDetached]
	return ok
}

// ResetDetached resets all changes to the "detached" field.
func (m *TaskMutation) ResetDetached() {
	m.detached = nil
	delete(m.clearedFields, task.FieldDetached)
}

// SetEnvironment sets the "environment" field.
func (m *TaskMutation) SetEnvironment(value map[string]interface{}) {
	m.environment = &value
}

// Environment returns the value of the "environment" field in the mutation.
func (m *TaskMutation) Environment() (r map[string]interface{}, exists bool) {
	v := m.environment
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironment returns the old "environment" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEnvironment(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnvironment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnvironment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironment: %w", err)
	}
	return oldValue.Environment, nil
}

// ClearEnvironment clears the value of the "environment" field.
func (m *TaskMutation) ClearEnvironment() {
	m.environment = nil
	m.clearedFields[task.FieldEnvironment] = struct{}{}
}

// EnvironmentCleared returns if the "environment" field was cleared in this mutation.
func (m *TaskMutation) EnvironmentCleared() bool {
	_, ok := m.clearedFields[task.FieldEnvironment]
	return ok
}

// ResetEnvironment resets all changes to the "environment" field.
func (m *TaskMutation) ResetEnvironment() {
	m.environment = nil
	delete(m.clearedFields, task.FieldEnvironment)
}

// SetPorts sets the "ports" field.
func (m *TaskMutation) SetPorts(s []string) {
	m.ports = &s
}

// Ports returns the value of the "ports" field in the mutation.
func (m *TaskMutation) Ports() (r []string, exists bool) {
	v := m.ports
	if v == nil {
		return
	}
	return *v, true
}

// OldPorts returns the old "ports" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPorts: %w", err)
	}
	return oldValue.Ports, nil
}

// ClearPorts clears the value of the "ports" field.
func (m *TaskMutation) ClearPorts() {
	m.ports = nil
	m.clearedFields[task.FieldPorts] = struct{}{}
}

// PortsCleared returns if the "ports" field was cleared in this mutation.
func (m *TaskMutation) PortsCleared() bool {
	_, ok := m.clearedFields[task.FieldPorts]
	return ok
}

// ResetPorts resets all changes to the "ports" field.
func (m *TaskMutation) ResetPorts() {
	m.ports = nil
	delete(m.clearedFields, task.FieldPorts)
}

// SetVolumes sets the "volumes" field.
func (m *TaskMutation) SetVolumes(s []string) {
	m.volumes = &s
}

// Volumes returns the value of the "volumes" field in the mutation.
func (m *TaskMutation) Volumes() (r []string, exists bool) {
	v := m.volumes
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumes returns the old "volumes" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldVolumes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVolumes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVolumes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumes: %w", err)
	}
	return oldValue.Volumes, nil
}

// ClearVolumes clears the value of the "volumes" field.
func (m *TaskMutation) ClearVolumes() {
	m.volumes = nil
	m.clearedFields[task.FieldVolumes] = struct{}{}
}

// VolumesCleared returns if the "volumes" field was cleared in this mutation.
func (m *TaskMutation) VolumesCleared() bool {
	_, ok := m.clearedFields[task.FieldVolumes]
	return ok
}

// ResetVolumes resets all changes to the "volumes" field.
func (m *TaskMutation) ResetVolumes() {
	m.volumes = nil
	delete(m.clearedFields, task.FieldVolumes)
}

// SetRestart sets the "restart" field.
func (m *TaskMutation) SetRestart(s string) {
	m.restart = &s
}

// Restart returns the value of the "restart" field in the mutation.
func (m *TaskMutation) Restart() (r string, exists bool) {
	v := m.restart
	if v == nil {
		return
	}
	return *v, true
}

// OldRestart returns the old "restart" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRestart(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRestart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRestart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestart: %w", err)
	}
	return oldValue.Restart, nil
}

// ClearRestart clears the value of the "restart" field.
func (m *TaskMutation) ClearRestart() {
	m.restart = nil
	m.clearedFields[task.FieldRestart] = struct{}{}
}

// RestartCleared returns if the "restart" field was cleared in this mutation.
func (m *TaskMutation) RestartCleared() bool {
	_, ok := m.clearedFields[task.FieldRestart]
	return ok
}

// ResetRestart resets all changes to the "restart" field.
func (m *TaskMutation) ResetRestart() {
	m.restart = nil
	delete(m.clearedFields, task.FieldRestart)
}

// SetSecurityOpt sets the "security_opt" field.
func (m *TaskMutation) SetSecurityOpt(s []string) {
	m.security_opt = &s
}

// SecurityOpt returns the value of the "security_opt" field in the mutation.
func (m *TaskMutation) SecurityOpt() (r []string, exists bool) {
	v := m.security_opt
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityOpt returns the old "security_opt" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldSecurityOpt(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSecurityOpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSecurityOpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityOpt: %w", err)
	}
	return oldValue.SecurityOpt, nil
}

// ClearSecurityOpt clears the value of the "security_opt" field.
func (m *TaskMutation) ClearSecurityOpt() {
	m.security_opt = nil
	m.clearedFields[task.FieldSecurityOpt] = struct{}{}
}

// SecurityOptCleared returns if the "security_opt" field was cleared in this mutation.
func (m *TaskMutation) SecurityOptCleared() bool {
	_, ok := m.clearedFields[task.FieldSecurityOpt]
	return ok
}

// ResetSecurityOpt resets all changes to the "security_opt" field.
func (m *TaskMutation) ResetSecurityOpt() {
	m.security_opt = nil
	delete(m.clearedFields, task.FieldSecurityOpt)
}

// SetCapAdd sets the "cap_add" field.
func (m *TaskMutation) SetCapAdd(s []string) {
	m.cap_add = &s
}

// CapAdd returns the value of the "cap_add" field in the mutation.
func (m *TaskMutation) CapAdd() (r []string, exists bool) {
	v := m.cap_add
	if v == nil {
		return
	}
	return *v, true
}

// OldCapAdd returns the old "cap_add" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCapAdd(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCapAdd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCapAdd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapAdd: %w", err)
	}
	return oldValue.CapAdd, nil
}

// ClearCapAdd clears the value of the "cap_add" field.
func (m *TaskMutation) ClearCapAdd() {
	m.cap_add = nil
	m.clearedFields[task.FieldCapAdd] = struct{}{}
}

// CapAddCleared returns if the "cap_add" field was cleared in this mutation.
func (m *TaskMutation) CapAddCleared() bool {
	_, ok := m.clearedFields[task.FieldCapAdd]
	return ok
}

// ResetCapAdd resets all changes to the "cap_add" field.
func (m *TaskMutation) ResetCapAdd() {
	m.cap_add = nil
	delete(m.clearedFields, task.FieldCapAdd)
}

// SetDeploymentID sets the "deployment" edge to the Deployment entity by id.
func (m *TaskMutation) SetDeploymentID(id uuid.UUID) {
	m.deployment = &id
}

// ClearDeployment clears the "deployment" edge to the Deployment entity.
func (m *TaskMutation) ClearDeployment() {
	m.cleareddeployment = true
}

// DeploymentCleared reports if the "deployment" edge to the Deployment entity was cleared.
func (m *TaskMutation) DeploymentCleared() bool {
	return m.cleareddeployment
}

// DeploymentID returns the "deployment" edge ID in the mutation.
func (m *TaskMutation) DeploymentID() (id uuid.UUID, exists bool) {
	if m.deployment != nil {
		return *m.deployment, true
	}
	return
}

// DeploymentIDs returns the "deployment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) DeploymentIDs() (ids []uuid.UUID) {
	if id := m.deployment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeployment resets all changes to the "deployment" edge.
func (m *TaskMutation) ResetDeployment() {
	m.deployment = nil
	m.cleareddeployment = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.image != nil {
		fields = append(fields, task.FieldImage)
	}
	if m.timeout != nil {
		fields = append(fields, task.FieldTimeout)
	}
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m.cmd != nil {
		fields = append(fields, task.FieldCmd)
	}
	if m.detached != nil {
		fields = append(fields, task.FieldDetached)
	}
	if m.environment != nil {
		fields = append(fields, task.FieldEnvironment)
	}
	if m.ports != nil {
		fields = append(fields, task.FieldPorts)
	}
	if m.volumes != nil {
		fields = append(fields, task.FieldVolumes)
	}
	if m.restart != nil {
		fields = append(fields, task.FieldRestart)
	}
	if m.security_opt != nil {
		fields = append(fields, task.FieldSecurityOpt)
	}
	if m.cap_add != nil {
		fields = append(fields, task.FieldCapAdd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldImage:
		return m.Image()
	case task.FieldTimeout:
		return m.Timeout()
	case task.FieldName:
		return m.Name()
	case task.FieldCmd:
		return m.Cmd()
	case task.FieldDetached:
		return m.Detached()
	case task.FieldEnvironment:
		return m.Environment()
	case task.FieldPorts:
		return m.Ports()
	case task.FieldVolumes:
		return m.Volumes()
	case task.FieldRestart:
		return m.Restart()
	case task.FieldSecurityOpt:
		return m.SecurityOpt()
	case task.FieldCapAdd:
		return m.CapAdd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldImage:
		return m.OldImage(ctx)
	case task.FieldTimeout:
		return m.OldTimeout(ctx)
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldCmd:
		return m.OldCmd(ctx)
	case task.FieldDetached:
		return m.OldDetached(ctx)
	case task.FieldEnvironment:
		return m.OldEnvironment(ctx)
	case task.FieldPorts:
		return m.OldPorts(ctx)
	case task.FieldVolumes:
		return m.OldVolumes(ctx)
	case task.FieldRestart:
		return m.OldRestart(ctx)
	case task.FieldSecurityOpt:
		return m.OldSecurityOpt(ctx)
	case task.FieldCapAdd:
		return m.OldCapAdd(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case task.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldCmd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmd(v)
		return nil
	case task.FieldDetached:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetached(v)
		return nil
	case task.FieldEnvironment:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironment(v)
		return nil
	case task.FieldPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPorts(v)
		return nil
	case task.FieldVolumes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumes(v)
		return nil
	case task.FieldRestart:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestart(v)
		return nil
	case task.FieldSecurityOpt:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityOpt(v)
		return nil
	case task.FieldCapAdd:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapAdd(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addtimeout != nil {
		fields = append(fields, task.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldTimeout) {
		fields = append(fields, task.FieldTimeout)
	}
	if m.FieldCleared(task.FieldName) {
		fields = append(fields, task.FieldName)
	}
	if m.FieldCleared(task.FieldCmd) {
		fields = append(fields, task.FieldCmd)
	}
	if m.FieldCleared(task.FieldDetached) {
		fields = append(fields, task.FieldDetached)
	}
	if m.FieldCleared(task.FieldEnvironment) {
		fields = append(fields, task.FieldEnvironment)
	}
	if m.FieldCleared(task.FieldPorts) {
		fields = append(fields, task.FieldPorts)
	}
	if m.FieldCleared(task.FieldVolumes) {
		fields = append(fields, task.FieldVolumes)
	}
	if m.FieldCleared(task.FieldRestart) {
		fields = append(fields, task.FieldRestart)
	}
	if m.FieldCleared(task.FieldSecurityOpt) {
		fields = append(fields, task.FieldSecurityOpt)
	}
	if m.FieldCleared(task.FieldCapAdd) {
		fields = append(fields, task.FieldCapAdd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldTimeout:
		m.ClearTimeout()
		return nil
	case task.FieldName:
		m.ClearName()
		return nil
	case task.FieldCmd:
		m.ClearCmd()
		return nil
	case task.FieldDetached:
		m.ClearDetached()
		return nil
	case task.FieldEnvironment:
		m.ClearEnvironment()
		return nil
	case task.FieldPorts:
		m.ClearPorts()
		return nil
	case task.FieldVolumes:
		m.ClearVolumes()
		return nil
	case task.FieldRestart:
		m.ClearRestart()
		return nil
	case task.FieldSecurityOpt:
		m.ClearSecurityOpt()
		return nil
	case task.FieldCapAdd:
		m.ClearCapAdd()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldImage:
		m.ResetImage()
		return nil
	case task.FieldTimeout:
		m.ResetTimeout()
		return nil
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldCmd:
		m.ResetCmd()
		return nil
	case task.FieldDetached:
		m.ResetDetached()
		return nil
	case task.FieldEnvironment:
		m.ResetEnvironment()
		return nil
	case task.FieldPorts:
		m.ResetPorts()
		return nil
	case task.FieldVolumes:
		m.ResetVolumes()
		return nil
	case task.FieldRestart:
		m.ResetRestart()
		return nil
	case task.FieldSecurityOpt:
		m.ResetSecurityOpt()
		return nil
	case task.FieldCapAdd:
		m.ResetCapAdd()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.deployment != nil {
		edges = append(edges, task.EdgeDeployment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeDeployment:
		if id := m.deployment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddeployment {
		edges = append(edges, task.EdgeDeployment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeDeployment:
		return m.cleareddeployment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeDeployment:
		m.ClearDeployment()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeDeployment:
		m.ResetDeployment()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}
